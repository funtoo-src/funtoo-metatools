#!/usr/bin/env python3
import os

from merge_utils.steps import (
	InsertFilesFromSubdir,
	SyncDir,
	SyncFiles,
	InsertEbuilds,
	GitCheckout,
	CleanTree,
	CopyFiles,
	PruneLicenses,
	ELTSymlinkWorkaround,
	CreateCategories,
	GenPythonUse,
	Minify,
	GenCache,
)
from merge_utils.tree import AutoCreatedGitTree


def copy_from_fixups_steps(hub, kit_dict=None):

	# Phase 3: copy eclasses, licenses, profile info, and ebuild/eclass fixups from the kit-fixups repository.

	# First, we are going to process the kit-fixups repository and look for ebuilds and eclasses to replace. Eclasses can be
	# overridden by using the following paths inside kit-fixups:

	# kit-fixups/eclass/1.2-release <--------- global eclasses, get installed to all kits unconditionally for release (overrides those above)
	# kit-fixups/<kit>/global/eclass <-------- global eclasses for a particular kit, goes in all branches (overrides those above)
	# kit-fixups/<kit>/global/profiles <------ global profile info for a particular kit, goes in all branches (overrides those above)
	# kit-fixups/<kit>/<branch>/eclass <------ eclasses to install in just a specific branch of a specific kit (overrides those above)
	# kit-fixups/<kit>/<branch>/profiles <---- profile info to install in just a specific branch of a specific kit (overrides those above)

	# Note that profile repo_name and categories files are excluded from any copying.

	# Ebuilds can be installed to kits by putting them in the following location(s):

	# kit-fixups/<kit>/global/cat/pkg <------- install cat/pkg into all branches of a particular kit
	# kit-fixups/<kit>/<branch>/cat/pkg <----- install cat/pkg into a particular branch of a kit

	# Remember that at this point, we may be missing a lot of eclasses and licenses from Gentoo. We will then perform a final sweep
	# of all catpkgs in the dest_kit and auto-detect missing eclasses from Gentoo and copy them to our dest_kit. Remember that if you
	# need a custom eclass from a third-party overlay, you will need to specify it in the overlay's overlays["ov_name"]["eclasses"]
	# list. Or alternatively you can copy the eclasses you need to kit-fixups and maintain them there :)

	steps = []
	# Here is the core logic that copies all the fix-ups from kit-fixups (eclasses and ebuilds) into place:
	eclass_release_path = "eclass/%s" % hub.RELEASE
	if os.path.exists(os.path.join(hub.FIXUP_REPO.root, eclass_release_path)):
		steps += [SyncDir(hub.FIXUP_REPO.root, eclass_release_path, "eclass")]
	fixup_dirs = ["global", "curated", kit_dict["branch"]]
	for fixup_dir in fixup_dirs:
		fixup_path = kit_dict["name"] + "/" + fixup_dir

		if os.path.exists(hub.FIXUP_REPO.root + "/" + fixup_path):
			if os.path.exists(hub.FIXUP_REPO.root + "/" + fixup_path + "/eclass"):
				steps += [
					InsertFilesFromSubdir(hub.FIXUP_REPO, "eclass", ".eclass", select="all", skip=None, src_offset=fixup_path)
				]
			if os.path.exists(hub.FIXUP_REPO.root + "/" + fixup_path + "/licenses"):
				steps += [InsertFilesFromSubdir(hub.FIXUP_REPO, "licenses", None, select="all", skip=None, src_offset=fixup_path)]
			if os.path.exists(hub.FIXUP_REPO.root + "/" + fixup_path + "/profiles"):
				steps += [
					InsertFilesFromSubdir(
						hub.FIXUP_REPO, "profiles", None, select="all", skip=["repo_name", "categories"], src_offset=fixup_path
					)
				]
			# copy appropriate kit readme into place:
			readme_path = fixup_path + "/README.rst"
			if os.path.exists(hub.FIXUP_REPO.root + "/" + readme_path):
				steps += [SyncFiles(hub.FIXUP_REPO.root, {readme_path: "README.rst"})]

			# We now add a step to insert the fixups, and we want to record them as being copied so successive kits
			# don't get this particular catpkg. Assume we may not have all these catpkgs listed in our package-set
			# file...

			steps += [InsertEbuilds(hub, hub.FIXUP_REPO, ebuildloc=fixup_path, select="all", skip=None, replace=True)]
	return steps


async def generate_autogenerated_kit(hub, kit_dict=None):

	"""

	This function will auto-generate a single 'autogenerated' kit by checking out the current version, wiping the
	contents of the git repo, and copying everything over again, updating metadata cache, etc. and then committing (and
	possibly pushing) the result.

	"""

	await hub.merge.sources.initialize_sources(kit_dict=kit_dict)

	if hub.GIT_CLASS_KWARGS_FN:
		kwargs = hub.GIT_CLASS_KWARGS_FN()
	else:
		kwargs = {}

	branch = kit_dict["branch"]
	out_tree = hub.GIT_CLASS(
		hub, kit_dict["name"], branch=branch, root=hub.MERGE_CONFIG.dest_trees + "/" + kit_dict["name"], **kwargs
	)
	await out_tree.initialize()

	# Phase 1: prep the kit
	steps = [GitCheckout(branch), CleanTree()]

	pre_steps, post_steps = hub.merge.foundations.get_kit_pre_post_steps(kit_dict)

	if pre_steps is not None:
		steps += pre_steps

	# Copy files specified in 'eclasses' and 'copyfiles' sections in the kit's YAML:

	for repo_name, copyfile_tuples in hub.merge.foundations.get_copyfiles_from_yaml(kit_dict["name"]).items():
		steps += [CopyFiles(hub.SOURCE_REPOS[repo_name], copyfile_tuples)]

	# Copy over catpkgs listed in 'packages' section:

	for repo_name, packages in hub.merge.foundations.get_kit_packages(kit_dict["name"]):
		from_tree = hub.SOURCE_REPOS[repo_name]
		# TODO: add move maps below
		steps += [InsertEbuilds(hub, from_tree, skip=None, replace=True, move_maps=None, select=packages)]

	# If an autogenerated kit, we also want to copy various things (catpkgs, eclasses, profiles) from kit-fixups:

	if kit_dict["kind"] == "autogenerated":
		steps += hub._.copy_from_fixups_steps(kit_dict)

	steps += [
		Minify(),
		ELTSymlinkWorkaround(),
		CreateCategories(),
		SyncDir(hub.SOURCE_REPOS["gentoo-staging"].root, "licenses"),
	]
	print(steps)
	await out_tree.run(steps)

	# Now, if we are core-kit, get hashes of all the eclasses so that we can generate metadata cache and use
	# it as needed:

	if kit_dict["name"] == "core-kit":
		hub.ECLASS_ROOT = out_tree.root
		hub.ECLASS_HASHES = hub.merge.metadata.get_eclass_hashes(hub.ECLASS_ROOT)

	# We will execute all the steps that we have queued up to this point, which will result in hub.METADATA_ENTRIES
	# being populated with all the metadata from the kit. Which will allow the next steps to run successfully.

	await out_tree.run([GenCache()])

	meta_steps = [PruneLicenses()]

	python_settings = hub.merge.foundations.python_kit_settings()

	for py_branch, py_settings in python_settings.items():
		meta_steps += [GenPythonUse(hub, py_settings, "funtoo/kits/python-kit/%s" % py_branch)]

	# We can now run all the steps that require access to metadata:

	await out_tree.run(meta_steps)

	await out_tree.gitCommit(message="updates", push=hub.PUSH)
	return kit_dict, out_tree, out_tree.head()


"""
async def generate_indy_kit(hub, kit_dict):
# TODO: this is not complete/tested
	name = kit_dict['name']
	tree = AutoCreatedGitTree(hub, name=name, root=hub.MERGE_CONFIG.dest_trees + "/" + kit_dict["name"], branch=kit_dict["branch"])
	await tree.gitCheckout(branch=kit_dict["branch"])
	post_steps = []
	python_settings = hub.merge.foundations.python_kit_settings()

	for py_branch, py_settings in python_settings.items():
		post_steps += [GenPythonUse(hub, py_settings, "funtoo/kits/python-kit/%s" % py_branch)]

	post_steps += [
		mu.Minify(),
		mu.GenUseLocalDesc(),
		mu.GenCache(cache_dir=config.metadata_cache + "/%s-%s-%s" % (release, kit_dict['name'], branch),
		            release=release),
	]
	await tree.run(post_steps)
	await tree.gitCommit(message="python USE setting and metadata cache updates")
"""
