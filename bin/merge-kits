#!/usr/bin/env python3

import asyncio
import os
import sys
from collections import defaultdict
from datetime import datetime

import pop.hub
import logging

from merge.config import Configuration
from merge.steps import GenPythonUse, getAllLicenses
from merge.steps import (
	InsertEbuilds,
	GitCheckout,
	CleanTree,
	ELTSymlinkWorkaround,
	CreateCategories,
	Minify,
	GenUseLocalDesc,
	GenCache,
	RunSed,
	SyncDir,
	ThirdPartyMirrors,
	SyncFiles,
	GenerateRepoMetadata,
)
from merge.tree import GitTree, AutoCreatedGitTree

hub_logger = logging.getLogger("pop.hub")
hub_logger.setLevel(logging.DEBUG)
hub = pop.hub.Hub()


async def auto_kit_gen(kit_dict=None):

	await hub.merge.sources.initialize_sources(kit_dict=kit_dict)

	if hub.GIT_CLASS_KWARGS_FN:
		kwargs = hub.GIT_CLASS_KWARGS_FN()
	else:
		kwargs = {}

	branch = kit_dict["branch"]
	out_tree = hub.GIT_CLASS(
		hub, kit_dict["name"], branch=branch, root=hub.MERGE_CONFIG.dest_trees + "/" + kit_dict["name"], **kwargs
	)
	await out_tree.initialize()

	# Phase 1: prep the kit
	steps = [GitCheckout(branch), CleanTree()]

	pre_steps, post_steps = hub.merge.foundations.get_kit_pre_post_steps(kit_dict)

	# TODO: process copyfiles and eclass sections from the packages.yaml.

	pre_steps.append(SyncDir(hub.SOURCE_REPOS["gentoo-staging"].root, "licenses"))

	for repo_name, packages in hub.merge.foundations.get_kit_packages(kit_dict["name"]):
		from_tree = hub.SOURCE_REPOS[repo_name]
		# TODO: add move maps below
		steps += [InsertEbuilds(hub, from_tree, skip=None, replace=True, move_maps=None, select=packages)]
	print("FONK", steps)
	sys.exit(0)

	# await out_tree.run(steps)

	# Phase 4: finalize and commit

	# remove unused licenses...

	if os.path.exists(out_tree.root + "/licenses"):
		used_licenses = await getAllLicenses(out_tree, hub.RELEASE)
		to_remove = []

		for license in os.listdir(out_tree.root + "/licenses"):
			if license not in used_licenses["dest_kit"]:
				to_remove.append(out_tree.root + "/licenses/" + license)
		for file in to_remove:
			os.unlink(file)

	post_steps += [
		ELTSymlinkWorkaround(),
		CreateCategories(),
	]

	python_settings = hub.merge.foundations.python_kit_settings()

	for py_branch, py_settings in python_settings.items():
		post_steps += [GenPythonUse(hub, py_settings, "funtoo/kits/python-kit/%s" % py_branch, release=hub.RELEASE)]

	post_steps += [
		Minify(),
		GenUseLocalDesc(),
		GenCache(
			cache_dir=config.metadata_cache + "/%s-%s-%s" % (hub.RELEASE, kit_dict["name"], branch), release=hub.RELEASE
		),
	]

	# post_steps += [
	# 	FastPullScan(now=hub.START_TIME)
	# ]

	await out_tree.run(post_steps)
	# push is ignored if we are using local AutoCreatedGitTrees.
	await out_tree.gitCommit(message="updates", push=push)
	return kit_dict, out_tree, out_tree.head()


"""
async def indy_kit_gen(kit_dict, release):
	name = kit_dict['name']
	tree = mu.AutoCreatedGitTree(name=name, root=path, config=config, branch=kit_dict["branch"])
	await tree.gitCheckout(branch=kit_dict["branch"])
	post_steps = []
	python_settings = foundation.python_kit_settings[release]

	for py_branch, py_settings in python_settings.items():
		post_steps += [mu.GenPythonUse(hub, py_settings, "funtoo/kits/python-kit/%s" % py_branch, release=release)]

	post_steps += [
		mu.Minify(),
		mu.GenUseLocalDesc(),
		mu.GenCache(cache_dir=config.metadata_cache + "/%s-%s-%s" % (release, kit_dict['name'], branch),
		            release=release),
	]
	await tree.run(post_steps)
	await tree.gitCommit(message="python USE setting and metadata cache updates")
"""


async def main_thread():

	if not hub.merge.foundations.release_exists(hub.RELEASE):
		print(f"Release not found: {hub.RELEASE}.")
		sys.exit(1)

	await hub.FIXUP_REPO.initialize()
	await hub.META_REPO.initialize()

	thread_groups = defaultdict(list)
	indy_kits = []

	for kit in hub.merge.foundations.kit_groups():
		kind = kit["kind"]
		if kind == "autogenerated":
			source = kit["source"]
			thread_groups[source].append(kit)
		else:
			indy_kits.append(kit)

	for gr_name, gr_list in thread_groups.items():
		print(gr_name)
		for kit in gr_list:
			print("  ", kit)

	# TODO: remove

	test_sources = list(thread_groups.keys())[0]
	kit_dict = thread_groups[test_sources][0]
	await auto_kit_gen(kit_dict=kit_dict)

	"""

			for kit_dict in release_kits:

				# Don't process kits that don't match:
				kit_branch = kit_dict["branch"]
				if "type" not in kit_dict or kit_dict["type"] != KitType.INDEPENDENTLY_MAINTAINED:
					continue
				if "name" not in kit_dict or kit_dict["name"] != kit_name:
					continue

				# Don't repeatedly process the same kit (can be defined in multiple releases)
				kit_key = "%s/%s" % (kit_name, kit_branch)
				if kit_key in already_processed_kit_keys:
					continue
				else:
					already_processed_kit_keys.add(kit_key)

				# OK, if we got here, we have something to process --
				print("Processing branch %s" % kit_dict["branch"])
				branch = kit_dict["branch"]
				indy_kit = 'type' in kit_dict and kit_dict['type'] == KitType.INDEPENDENTLY_MAINTAINED


"""


if __name__ == "__main__":
	sub_name = os.path.basename(sys.argv[0])
	int_g = [sub_name, "pkgtools"]

	hub.pop.conf.integrate(int_g, cli=sub_name, roots=True, loader="yaml", logs=False)

	print("Why hello there.")
	push = not hub.OPT["merge-kits"]["nopush"]
	prod = hub.OPT["merge-kits"]["prod"]
	forcepush = hub.OPT["merge-kits"]["force"]
	print(hub.OPT["merge-kits"]["release"])
	print("prod:", prod)
	print("push:", push)

	hub.MERGE_CONFIG = config = Configuration()
	hub.RELEASE = hub.OPT["merge-kits"]["release"]

	local_merge = not prod
	if local_merge is True:
		# This means we'll just generate our own local git trees for the purposes of generating kits. This is generally used by developers to see what
		# would end up in kits, when you don't really need to create any kits that will be used anywhere else.
		hub.GIT_CLASS = AutoCreatedGitTree
		hub.GIT_CLASS_KWARGS_FN = None
		hub.PUSH = False
		hub.META_REPO = meta_repo = hub.GIT_CLASS(
			hub, name="meta-repo", branch=config.branch("meta-repo"), root=config.dest_trees + "/meta-repo"
		)
		hub.NEST_KITS = True
	else:

		def get_git_class_kwargs(kit_dict):
			return {
				"url": hub.MERGE_CONFIG.base_url(kit_dict["name"]),
				"mirror": hub.MERGE_CONFIG.mirror.rstrip("/") + "/" + kit_dict["name"] if hub.MERGE_CONFIG.mirror else None,
				"origin_check": True,
				"destfix": False,
				"forcepush": forcepush,
			}

		# In this mode, we're actually wanting to update real kits, and likely are going to push our updates to remotes (unless --nopush is specified as an arg.)
		# This might be used by people generating their own custom kits for use on other systems, or by Funtoo itself for updating official kits and meta-repo.
		hub.GIT_CLASS = GitTree
		hub.GIT_CLASS_KWARGS_FN = get_git_class_kwargs
		hub.META_REPO = meta_repo = GitTree(
			hub,
			"meta-repo",
			config.branch("meta-repo"),
			url=config.base_url("meta-repo"),
			root=config.dest_trees + "/meta-repo",
			mirror=config.mirror.rstrip("/") + "/meta-repo" if config.mirror else None,
			origin_check=True,
		)
		hub.NEST_KITS = False
		hub.PUSH = push

	hub.START_TIME = datetime.utcnow()
	hub.FIXUP_REPO = GitTree(
		hub,
		"kit-fixups",
		hub.MERGE_CONFIG.branch("kit-fixups"),
		url=hub.MERGE_CONFIG.kit_fixups,
		root=hub.MERGE_CONFIG.source_trees + "/kit-fixups",
	)

	hub.pop.sub.add("funtoo.merge")

	# TODO: hook into fastpull

	loop = asyncio.get_event_loop()
	loop.run_until_complete(main_thread())
	sys.exit(0)

# vim: ts=4 sw=4 noet
