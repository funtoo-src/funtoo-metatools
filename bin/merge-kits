#!/usr/bin/env python3

import asyncio
import logging
import os
import sys
from collections import defaultdict
from datetime import datetime

import pop.hub

from merge_utils.config import Configuration
from merge_utils.tree import GitTree, AutoCreatedGitTree

hub_logger = logging.getLogger("pop.hub")
hub_logger.setLevel(logging.DEBUG)
hub = pop.hub.Hub()


class MergeError(Exception):
	pass


async def main_thread():

	if not hub.merge.foundations.release_exists(hub.RELEASE):
		print(f"Release not found: {hub.RELEASE}.")
		sys.exit(1)

	await hub.FIXUP_REPO.initialize()
	await hub.META_REPO.initialize()

	core_kit = None
	thread_groups = defaultdict(list)
	indy_kits = []

	for kit in hub.merge.foundations.kit_groups():
		kind = kit["kind"]

		# core-kit is special, and we want to grab it because we need to do special initialization with eclasses,
		# etc. since these eclasses get used for metadata cache generation for successive kits.

		if kit["name"] == "core-kit":
			core_kit = kit
		elif kind == "autogenerated":

			# thread_groups is a collection of kits that are all using the same source repos. They can in theory
			# be processed in parallel, thus the name 'thread groups'.

			thread_groups[kit["source"]].append(kit)
		else:

			# Independent kits in theory need no processing, though we may add some good-to-have processing like
			# ensuring all metadata cache is up-to-date. This would be a good thing, actually.

			indy_kits.append(kit)

	if core_kit is None:
		raise MergeError(f"Unable to find core-kit in source definitions for release {hub.RELEASE}.")

	await hub.merge.kit.generate_autogenerated_kit(core_kit)

	for gr_name, gr_list in thread_groups.items():
		for kit in gr_list:
			await hub.merge.kit.generate_autogenerated_kit(kit)


if __name__ == "__main__":
	sub_name = os.path.basename(sys.argv[0])
	int_g = [sub_name, "pkgtools"]

	hub.pop.conf.integrate(int_g, cli=sub_name, roots=True, loader="yaml", logs=False)

	# Parse options:

	push = not hub.OPT["merge-kits"]["nopush"]
	prod = hub.OPT["merge-kits"]["prod"]
	forcepush = hub.OPT["merge-kits"]["force"]

	# Initialize internal pop globals that are expected to be in place when the merge sub gets added:

	hub.MERGE_CONFIG = config = Configuration(prod=prod)
	hub.RELEASE = hub.OPT["merge-kits"]["release"]

	local_merge = not prod
	if local_merge is True:
		# This means we'll just generate our own local git trees for the purposes of generating kits. This is generally used by developers to see what
		# would end up in kits, when you don't really need to create any kits that will be used anywhere else.
		hub.GIT_CLASS = AutoCreatedGitTree
		hub.GIT_CLASS_KWARGS_FN = None
		hub.PUSH = False
		hub.META_REPO = meta_repo = hub.GIT_CLASS(
			hub, name="meta-repo", branch=config.branch("meta-repo"), root=config.dest_trees + "/meta-repo"
		)
		hub.NEST_KITS = True
	else:

		def get_git_class_kwargs(kit_dict):
			return {
				"url": hub.MERGE_CONFIG.base_url(kit_dict["name"]),
				"origin_check": True,
				"destfix": False,
				"forcepush": forcepush,
			}

		# In this mode, we're actually wanting to update real kits, and likely are going to push our updates to remotes (unless --nopush is specified as an arg.)
		# This might be used by people generating their own custom kits for use on other systems, or by Funtoo itself for updating official kits and meta-repo.

		hub.GIT_CLASS = GitTree
		hub.GIT_CLASS_KWARGS_FN = get_git_class_kwargs
		hub.META_REPO = meta_repo = GitTree(
			hub,
			"meta-repo",
			config.branch("meta-repo"),
			url=config.base_url("meta-repo"),
			root=config.dest_trees + "/meta-repo",
			origin_check=True,
		)
		hub.NEST_KITS = False
		hub.PUSH = push

	hub.START_TIME = datetime.utcnow()
	hub.FIXUP_REPO = GitTree(
		hub,
		"kit-fixups",
		hub.MERGE_CONFIG.branch("kit-fixups"),
		url=hub.MERGE_CONFIG.kit_fixups,
		root=hub.MERGE_CONFIG.source_trees + "/kit-fixups",
	)

	hub.pop.sub.add("funtoo.merge")

	# TODO: hook into fastpull
	hub.CPM_LOGGER = None

	# Our autogen scripts will call "doit" (which actually hits this code base again, but as a separate process) and
	# AUTOGEN_OPTS is used to define the correct arguments to supply to the "doit" call depending on what behavior
	# we want:

	hub.AUTOGEN_OPTS = [f"--temp-path={os.path.join(config.work_path, 'autogen')}"]
	if prod:
		hub.AUTOGEN_OPTS.append("--cacher=mongodb")
	hub.AUTOGEN_OPTS = " ".join(hub.AUTOGEN_OPTS)

	loop = asyncio.get_event_loop()
	loop.run_until_complete(main_thread())
	sys.exit(0)

# vim: ts=4 sw=4 noet
