#!/usr/bin/env python3

import asyncio
import logging
import os
import sys
from collections import defaultdict, OrderedDict
from datetime import datetime

import pop.hub

from merge_utils.config import Configuration
from merge_utils.tree import GitTree, AutoCreatedGitTree

hub_logger = logging.getLogger("pop.hub")
hub_logger.setLevel(logging.DEBUG)
hub = pop.hub.Hub()


class MergeError(Exception):
	pass


def run_async_adapter(corofn, *args):
	"""
	Use this method to run an asynchronous worker within a ThreadPoolExecutor.
	Without this special wrapper, this normally doesn't work, and the
	ThreadPoolExecutor will not allow async calls.  But with this wrapper, our
	worker and its subsequent calls can be async.

	Use as follows::

		futures =[
			hub.LOOP.run_in_executor(hub.CPU_BOUND_EXECUTOR, run_async_adapter, self.worker_async, worker_async_arg1, ...)
			for meta_pkg_ebuild_path in all_meta_pkg_ebuilds
		]
		for future in asyncio.as_completed(futures):
			...

	"""
	loop = asyncio.new_event_loop()
	try:
		future = corofn(*args)
		asyncio.set_event_loop(loop)
		return loop.run_until_complete(future)
	finally:
		loop.close()


async def main_thread():

	# Before we start looking at YAML, we need to ensure our two critical source repos are checked out

	await hub.META_REPO.initialize()
	await hub.FIXUP_REPO.initialize()

	hub.KIT_GROUPS = list(hub.merge.foundations.kit_groups())

	if not hub.merge.foundations.release_exists(hub.RELEASE):
		print(f"Release not found: {hub.RELEASE}.")
		sys.exit(1)

	core_kit = None

	# Collect kits into groups based on what source repository definitions they use. We will keep the keys
	# (source definition names) in a list to preserve the original ordering (dict won't do this for us):

	thread_keys = []
	thread_groups = defaultdict(list)

	for kit in hub.KIT_GROUPS:
		kind = kit["kind"]

		# core-kit is special, and we want to grab it because we need to do special initialization with eclasses,
		# etc. since these eclasses get used for metadata cache generation for successive kits.

		if kit["name"] == "core-kit":
			core_kit = kit
		elif kind == "autogenerated":
			if kit["source"] not in thread_keys:
				thread_keys.append(kit["source"])
			thread_groups[kit["source"]].append(kit)
		elif kind == "independent":
			if "independent" not in thread_keys:
				thread_keys.append("independent")
			thread_groups["independent"].append(kit)

	if core_kit is None:
		raise MergeError(f"Unable to find core-kit in source definitions for release {hub.RELEASE}.")

	kit_results = OrderedDict()
	kit_sha1s = defaultdict(dict)
	# Generate core-kit:

	await hub.merge.sources.initialize_sources(core_kit["source"])
	kit_dict, tree_obj, tree_sha1 = await hub.merge.kit.generate_kit(core_kit)
	kit_results[kit_dict["name"]] = (kit_dict, tree_obj, tree_sha1)
	kit_sha1s[kit_dict["name"]][kit_dict["branch"]] = tree_sha1
	# Generate all other kits:

	for source in thread_keys:
		kit_dict_list = thread_groups[source]
		if source != "independent":
			await hub.merge.sources.initialize_sources(source)
		for kit in kit_dict_list:
			# Generate a kit. Record results for later add to meta-repo metadata:
			kit_dict, tree_obj, tree_sha1 = await hub.merge.kit.generate_kit(kit)
			kit_results[kit_dict["name"]] = (kit_dict, tree_obj, tree_sha1)
			kit_sha1s[kit_dict["name"]][kit_dict["branch"]] = tree_sha1

	# Create meta-repo commit referencing our updated kits:
	hub.merge.kit.generate_metarepo_metadata(kit_sha1s)
	await hub.META_REPO.gitCommit(message="kit updates", skip=["kits"], push=False)

	if hub.PUSH:
		# Push all kits, then push meta-repo.
		for kit_name, kit_tuple in kit_results.items():
			kit_dict, tree_obj, tree_sha1 = kit_tuple
			await tree_obj.gitMirrorPush()
		await hub.META_REPO.gitMirrorPush()


if __name__ == "__main__":
	sub_name = os.path.basename(sys.argv[0])
	int_g = [sub_name, "pkgtools"]

	hub.pop.conf.integrate(int_g, cli=sub_name, roots=True, loader="yaml", logs=False)

	# Parse options:

	push = not hub.OPT["merge-kits"]["nopush"]
	prod = hub.OPT["merge-kits"]["prod"]
	forcepush = hub.OPT["merge-kits"]["force"]

	# Initialize internal pop globals that are expected to be in place when the merge sub gets added:

	hub.MERGE_CONFIG = config = Configuration(prod=prod)
	hub.RELEASE = hub.OPT["merge-kits"]["release"]

	if not prod:
		# This means we'll just generate our own local git trees for the purposes of generating kits. This is generally used by developers to see what
		# would end up in kits, when you don't really need to create any kits that will be used anywhere else.
		hub.GIT_CLASS = AutoCreatedGitTree
		hub.GIT_CLASS_KWARGS_FN = None
		hub.PUSH = False
		hub.MIRROR = False
		hub.META_REPO = meta_repo = hub.GIT_CLASS(
			hub, name="meta-repo", branch=config.branch("meta-repo"), root=config.dest_trees + "/meta-repo"
		)
		hub.NEST_KITS = True
	else:

		# In this mode, we're actually wanting to update real kits, and likely are going to push our updates to remotes (unless --nopush is specified as an arg.)
		# This might be used by people generating their own custom kits for use on other systems, or by Funtoo itself for updating official kits and meta-repo.

		hub.NEST_KITS = False
		hub.PUSH = push
		hub.MIRROR = push
		hub.GIT_CLASS = GitTree
		hub.META_REPO = meta_repo = GitTree(
			hub,
			"meta-repo",
			branch=hub.RELEASE,
			url=config.meta_repo,
			root=config.dest_trees + "/meta-repo",
			origin_check=True,
			mirror=hub.MERGE_CONFIG.mirror.rstrip("/") + "/meta-repo" if hub.MIRROR else None,
		)

	hub.START_TIME = datetime.utcnow()
	hub.FIXUP_REPO = GitTree(
		hub, "kit-fixups", config.branch("kit-fixups"), url=config.kit_fixups, root=config.source_trees + "/kit-fixups",
	)

	hub.pop.sub.add("funtoo.merge")
	hub.pop.sub.add("funtoo.pkgtools")

	# TODO: hook into fastpull
	hub.CPM_LOGGER = None

	# Our autogen scripts will call "doit" (which actually hits this code base again, but as a separate process) and
	# AUTOGEN_OPTS is used to define the correct arguments to supply to the "doit" call depending on what behavior
	# we want:

	hub.AUTOGEN_OPTS = [f"--temp-path={os.path.join(config.work_path, 'autogen')}"]
	if prod:
		hub.AUTOGEN_OPTS.append("--cacher=mongodb")
	hub.AUTOGEN_OPTS = " ".join(hub.AUTOGEN_OPTS)

	loop = asyncio.get_event_loop()
	loop.run_until_complete(main_thread())

	if len(hub.METADATA_ERRORS):
		print()
		print("The following errors were encountered during processing:")
		print()
		for error in hub.METADATA_ERRORS:
			print(f"{error.severity}: {error.ebuild_path}: {error.msg}")
			if error.output:
				print("Output: " + error.output)
				print()

	sys.exit(0)

# vim: ts=4 sw=4 noet
