#!/usr/bin/env python3

import asyncio
import logging
import os
import sys
from collections import defaultdict, OrderedDict
from concurrent.futures import as_completed
from concurrent.futures.thread import ThreadPoolExecutor
from datetime import datetime

import pop.hub

from funtoo.pkgtools.thread import run_async_adapter
from merge_utils.config import Configuration
from merge_utils.tree import GitTree, AutoCreatedGitTree

hub_logger = logging.getLogger("pop.hub")
hub_logger.setLevel(logging.DEBUG)
hub = pop.hub.Hub()


class MergeError(Exception):
	pass


async def main_thread():

	# Before we start looking at YAML, we need to ensure our two critical source repos are checked out

	hub.META_REPO.initialize()
	hub.FIXUP_REPO.initialize()

	hub.KIT_GROUPS = list(hub.merge.foundations.kit_groups())

	if not hub.merge.foundations.release_exists(hub.RELEASE):
		print(f"Release not found: {hub.RELEASE}.")
		sys.exit(1)

	thread_keys, thread_groups = hub.merge.sources.get_kits_in_correct_processing_order()

	hub.KIT_RESULTS = OrderedDict()
	hub.KIT_SHA1S = defaultdict(dict)

	# This will generate core-kit, as well as all other kits:
	for source in thread_keys:
		kit_dict_list = thread_groups[source]
		regen_futures = []
		with ThreadPoolExecutor(max_workers=4) as executor:

			# Initialize sources based on the settings of the first kit in the group (they are all identical)
			kit_dict = kit_dict_list[0]
			if kit_dict["kind"] != "independent":
				await hub.merge.sources.initialize_sources(kit_dict["source"])
			for kit_dict in kit_dict_list:
				future = executor.submit(run_async_adapter, hub.merge.kit.generate_kit, kit_dict)
				regen_futures.append(future)
			for future in as_completed(regen_futures):
				kit_dict, tree_obj, tree_sha1 = future.result()
				hub.KIT_RESULTS[kit_dict["name"]] = (kit_dict, tree_obj, tree_sha1)
				hub.KIT_SHA1S[kit_dict["name"]][kit_dict["branch"]] = tree_sha1

	# Create meta-repo commit referencing our updated kits:
	hub.merge.kit.generate_metarepo_metadata(hub.KIT_SHA1S)
	hub.META_REPO.gitCommit(message="kit updates", skip=["kits"], push=hub.PUSH)

	if not hub.MIRROR:
		hub.merge.metadata.display_error_summary()
		return

	# Mirroring to GitHub happens here:

	kit_mirror_futures = []
	with ThreadPoolExecutor(max_workers=8) as executor:
		# Push all kits, then push meta-repo.
		for kit_name, kit_tuple in hub.KIT_RESULTS.items():
			kit_dict, tree_obj, tree_sha1 = kit_tuple
			future = executor.submit(hub.merge.kit.mirror_repository, tree_obj)
			kit_mirror_futures.append(future)
		for future in as_completed(kit_mirror_futures):
			kit_name = future.result()
			print(f"Mirroring of {kit_name} complete.")

	hub.merge.kit.mirror_repository(hub.META_REPO)
	print("Mirroring of meta-repo complete.")
	hub.merge.metadata.display_error_summary()


if __name__ == "__main__":
	sub_name = os.path.basename(sys.argv[0])
	int_g = [sub_name, "pkgtools"]

	hub.pop.conf.integrate(int_g, cli=sub_name, roots=True, loader="yaml", logs=False)

	# Parse options:

	push = not hub.OPT["merge-kits"]["nopush"]
	hub.PROD = prod = hub.OPT["merge-kits"]["prod"]
	forcepush = hub.OPT["merge-kits"]["force"]

	# Initialize internal pop globals that are expected to be in place when the merge sub gets added:

	hub.MERGE_CONFIG = config = Configuration(prod=prod)
	hub.RELEASE = hub.OPT["merge-kits"]["release"]

	if not prod:
		# This means we'll just generate our own local git trees for the purposes of generating kits. This is generally used by developers to see what
		# would end up in kits, when you don't really need to create any kits that will be used anywhere else.
		hub.GIT_CLASS = AutoCreatedGitTree
		hub.GIT_CLASS_KWARGS_FN = None
		hub.PUSH = False
		hub.MIRROR = False
		hub.META_REPO = meta_repo = hub.GIT_CLASS(
			hub, name="meta-repo", branch=hub.RELEASE, root=config.dest_trees + "/meta-repo"
		)
		hub.NEST_KITS = True
	else:

		# In this mode, we're actually wanting to update real kits, and likely are going to push our updates to remotes (unless --nopush is specified as an arg.)
		# This might be used by people generating their own custom kits for use on other systems, or by Funtoo itself for updating official kits and meta-repo.

		hub.NEST_KITS = False
		hub.PUSH = push
		hub.MIRROR = push
		hub.GIT_CLASS = GitTree

		kwargs = {}
		if hub.MIRROR:
			kwargs["mirror"] = hub.MERGE_CONFIG.mirror.rstrip("/") + "/meta-repo"
		hub.META_REPO = meta_repo = GitTree(
			hub,
			"meta-repo",
			branch=hub.RELEASE,
			url=config.meta_repo,
			root=config.dest_trees + "/meta-repo",
			origin_check=True,
			**kwargs,
		)

	hub.START_TIME = datetime.utcnow()
	hub.FIXUP_REPO = GitTree(
		hub, "kit-fixups", config.branch("kit-fixups"), url=config.kit_fixups, root=config.source_trees + "/kit-fixups",
	)

	hub.pop.sub.add("funtoo.merge")
	hub.pop.sub.add("funtoo.pkgtools")
	hub.pop.sub.add("funtoo.cache")

	hub.CPM_LOGGER = None

	loop = asyncio.get_event_loop()
	loop.set_debug(enabled=True)
	loop.run_until_complete(main_thread())

	# if len(hub.METADATA_ERRORS):
	# 	print()
	# 	print("The following errors were encountered during processing:")
	# 	print()
	# 	for error in hub.METADATA_ERRORS:
	# 		print(f"{error.severity}: {error.ebuild_path}: {error.msg}")
	# 		if error.output:
	# 			print("Output: " + error.output)
	# 			print()

	sys.exit(0)

# vim: ts=4 sw=4 noet
