#!/usr/bin/env python3

import argparse
import asyncio
import os
import signal
import sys

import psutil
from subpop.hub import Hub

from metatools.config.merge import MergeConfig
from metatools.kit import MetaRepoJobController

hub = Hub()


# Added this to properly and immediately terminate all tasks and subprocesses:


async def do_process_teardown():
	cur_proc = psutil.Process()
	children = cur_proc.children()
	for pid in children:
		try:
			pid.send_signal(signal.SIGKILL)
		except ProcessLookupError:
			pass

	async def cleanup():
		tasks = [t for t in asyncio.all_tasks() if t is not asyncio.current_task()]
		[task.cancel() for task in tasks]

	await cleanup()

	# Kill any active threads:
	os.kill(os.getpid(), 9)


async def main_thread(args):
	model = MergeConfig()
	await model.initialize(
		release=args.release,
		prod=args.prod,
		push=not args.nopush,
		create_branches=args.create_branches,
		fixups_url=args.fixups_url,
		fixups_branch=args.fixups_branch,
		debug=args.debug
	)
	controller = MetaRepoJobController(model)
	try:
		await controller.generate()
	except KeyboardInterrupt:
		model.log.error("Keyboard interrupt -- shutting down.")
		await do_process_teardown()


	pos = 0

	for kit_dict in repo_plus_overlays:
		ctx = NamespaceDict()
		ctx["kit"] = NamespaceDict(kit_dict)
		out_tree = await merge.kit.checkout_kit(ctx)

		if pos == 0:
			merge.model.ECLASS_ROOT = out_tree.root
			merge.model.ECLASS_HASHES = merge.metadata.get_eclass_hashes(
					merge.model.ECLASS_ROOT
			)

		merge.metadata.fetch_kit(out_tree)
		merge.metadata.gen_cache(out_tree)
		merge.metadata.flush_kit(out_tree)
		pos += 1


def load_specs(specs):
	ans = []
	m = {}
	for f in specs:
		if not os.path.exists(f):
			logging.error("File %s not found." % f)
			sys.exit(1)

		with open(f) as yf:
			data = yaml.load(yf, Loader=yaml.FullLoader)

		if 'name' not in data or 'url' not in data:
			logging.error("Invalid file %s." % f)
			sys.exit(1)

		if "commit_sha1" not in data:
			data["commit_sha1"] = None

		# Get only last repository of the specified name.
		m[data['name']] = data

	for k, v in m.items():
		ans.append(v)

	return ans


CLI_CONFIG = {
	"fixups_url": {"type": str},
	"fixups_branch": {"type": str, "default": "master"},
	"release": {"positional": True},
	"debug": {"action": "store_true", "default": False}
}


def parse_args():
	ap = argparse.ArgumentParser()
	for arg, kwargs in CLI_CONFIG.items():
		if "os" in kwargs:
			del kwargs["os"]
		if "positional" in kwargs and kwargs["positional"]:
			new_kwargs = kwargs.copy()
			del new_kwargs["positional"]
			ap.add_argument(arg, **new_kwargs)
		else:
			ap.add_argument("--" + arg, **kwargs)
	return ap.parse_args()


if __name__ == "__main__":
	args = parse_args()
	hub.LOOP.run_until_complete(main_thread(args))
	sys.exit(0)



# vim: ts=4 sw=4 noet
